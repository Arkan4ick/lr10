# Отчет по лабораторной работе 10

## Задача
Численное интегрирование функции методом прямоугольников.
Оптимизация алгоритма разными способами.

## Итерация 1: Чистый Python
**Файл:** `integrate.py`

- Функция `integrate()` с аннотациями типов (PEP 484)
- Docstring с примерами (PEP 257)
- 2 doctest примера
- 6 unittest тестов

**Результаты:**
```
test_sin: PASS
test_cos: PASS
test_quadratic: PASS
test_linear: PASS
test_constant: PASS
test_stability: PASS
```

**Время выполнения (n_iter=100000):** ~0.05s

---

## Итерация 2: Многопоточность
**Файл:** `integrate_threading.py`

- Функция `integrate_threads()` с ThreadPoolExecutor
- Разбивка интеграла на части между потоками

**Результаты:**
```
Потоки (2 шт): ~0.06s
Потоки (4 шт): ~0.08s
Потоки (8 шт): ~0.10s
```

**Вывод:** Потоки медленнее из-за GIL (Python < 3.13)

---

## Итерация 3: Многопроцессность
**Файл:** `integrate_threading.py`

- Функция `integrate_processes()` с ProcessPoolExecutor
- Каждый процесс имеет собственный интерпретатор Python

**Результаты:**
```
Процессы (2 шт): ~0.10s
Процессы (4 шт): ~0.15s
Процессы (8 шт): ~0.20s
```

**Вывод:** Процессы ещё медленнее из-за оверхеда создания

---

## Итерация 4: Cython оптимизация
**Файлы:** `integrate_cython.pyx`, `setup.py`, `benchmark_cython.py`

- Cython функции `integrate_sin_fast()`, `integrate_cos_fast()`
- Использование C типов для максимальной скорости
- Встроенные C функции sin/cos из libc.math

**Результаты:**
```
Python: ~0.05s
Cython: ~0.001s
Ускорение: ~50x
```

**Вывод:** Cython - лучший выбор для CPU-bound задач

---

## Итерация 5: Анализ noGIL
**Файл:** `nogil_analysis.py`

- Проверка версии Python
- Сравнение однопоточной и многопоточной обработки

**Результаты (Python < 3.13):**
```
Один поток: ~0.05s
Четыре потока: ~0.08s
```

**Вывод:** GIL ограничивает многопоточность. Нужна Cython или Python 3.13+

---

## Сравнительная таблица

| Метод | Время (s) | Ускорение | Плюсы | Минусы |
|-------|-----------|-----------|-------|--------|
| Python | 0.050 | 1.0x | Простой | Медленный |
| Потоки | 0.080 | 0.6x | - | GIL замедляет |
| Процессы | 0.150 | 0.3x | - | Оверхед |
| Cython | 0.001 | 50x | Очень быстро | Надо компилировать |

---

## Выводы

1. **Для CPU-bound задач в Python используйте Cython** - даёт 50x ускорение

2. **Потоки не помогают** из-за GIL в Python < 3.13

3. **Процессы медленнее потоков** из-за оверхеда IPC

4. **Простой Python** - только для прототипирования